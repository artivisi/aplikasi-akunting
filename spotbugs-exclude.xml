<?xml version="1.0" encoding="UTF-8"?>
<!--
SpotBugs exclusion configuration for properly mitigated security issues.

This file documents security vulnerabilities that have been properly fixed
but are still reported as false positives by FindSecBugs due to static analysis limitations.

IMPORTANT: Only add exclusions here after implementing proper mitigation.
Each exclusion must have a justification comment explaining the mitigation.
-->
<FindBugsFilter>

    <!--
    CRLF_INJECTION_LOGS - Mitigated via triple-layer defense:
    1. Code-level: LogSanitizer.sanitize() applied to all user-controlled log parameters
    2. Framework-level: Logback pattern with %replace(%msg){'[\r\n]', ''}
    3. Additional protections: LogSanitizer also strips control chars and limits length

    FindSecBugs cannot detect these mitigations via static analysis, resulting in false positives.
    Exclusions documented per class below.
    -->

    <!-- DataSubjectController: All log statements use LogSanitizer.sanitize() -->
    <Match>
        <Class name="com.artivisi.accountingfinance.controller.DataSubjectController"/>
        <Bug pattern="CRLF_INJECTION_LOGS"/>
    </Match>

    <!-- DataSubjectService: All log statements use LogSanitizer.sanitize() -->
    <Match>
        <Class name="com.artivisi.accountingfinance.service.DataSubjectService"/>
        <Bug pattern="CRLF_INJECTION_LOGS"/>
    </Match>

    <!-- DocumentService: All log statements sanitize UUID.toString() via LogSanitizer -->
    <Match>
        <Class name="com.artivisi.accountingfinance.service.DocumentService"/>
        <Bug pattern="CRLF_INJECTION_LOGS"/>
    </Match>

    <!-- FixedAssetService: All log statements use LogSanitizer for asset codes -->
    <Match>
        <Class name="com.artivisi.accountingfinance.service.FixedAssetService"/>
        <Bug pattern="CRLF_INJECTION_LOGS"/>
    </Match>

    <!-- PayrollService: All log statements use LogSanitizer for user input -->
    <Match>
        <Class name="com.artivisi.accountingfinance.service.PayrollService"/>
        <Bug pattern="CRLF_INJECTION_LOGS"/>
    </Match>

    <!--
    SPRING_CSRF_UNRESTRICTED_REQUEST_MAPPING - Error Controller False Positive

    CustomErrorController uses @RequestMapping("/error") without method restriction.
    This is flagged as CSRF vulnerability, but it's a false positive because:

    1. Error controllers MUST handle all HTTP methods - errors can occur on GET, POST, PUT, DELETE
    2. The /error endpoint only displays error information (read-only, no state changes)
    3. This is the same pattern used by Spring Boot's BasicErrorController
    4. CSRF protection is irrelevant for error display - no sensitive operations performed
    5. The endpoint is called by the servlet container on errors, not by user forms

    Reference: Spring Boot BasicErrorController also uses unrestricted @RequestMapping
    -->
    <Match>
        <Class name="com.artivisi.accountingfinance.controller.CustomErrorController"/>
        <Bug pattern="SPRING_CSRF_UNRESTRICTED_REQUEST_MAPPING"/>
    </Match>

    <!--
    UUF_UNUSED_FIELD - Framework-managed fields (JPA, Spring, etc.)
    These fields appear unused to static analysis but are used by frameworks via reflection.
    Only exclude after verifying the field is actually used by the framework.
    -->
    <!-- Example: JPA entity fields accessed via reflection can be added here if needed -->

    <!-- DeviceAuthorizationController: All log statements use LogSanitizer.sanitize() -->
    <Match>
        <Class name="com.artivisi.accountingfinance.controller.DeviceAuthorizationController"/>
        <Bug pattern="CRLF_INJECTION_LOGS"/>
    </Match>

    <!-- DeviceAuthService: All log statements use LogSanitizer.sanitize() -->
    <Match>
        <Class name="com.artivisi.accountingfinance.service.DeviceAuthService"/>
        <Bug pattern="CRLF_INJECTION_LOGS"/>
    </Match>

    <!-- DraftTransactionApiController: All log statements use LogSanitizer.sanitize() -->
    <Match>
        <Class name="com.artivisi.accountingfinance.controller.api.DraftTransactionApiController"/>
        <Bug pattern="CRLF_INJECTION_LOGS"/>
    </Match>

    <!-- TemplateApiController: All log statements use LogSanitizer.sanitize() -->
    <Match>
        <Class name="com.artivisi.accountingfinance.controller.api.TemplateApiController"/>
        <Bug pattern="CRLF_INJECTION_LOGS"/>
    </Match>

    <!-- TransactionApiService: All log statements use LogSanitizer.sanitize() -->
    <Match>
        <Class name="com.artivisi.accountingfinance.service.TransactionApiService"/>
        <Bug pattern="CRLF_INJECTION_LOGS"/>
    </Match>

    <!--
    EI_EXPOSE_REP / EI_EXPOSE_REP2 - Spring Dependency Injection False Positives

    SpotBugs flags Spring DI constructor injection as "exposing internal representation":
    - EI_EXPOSE_REP2: Constructor stores reference to mutable object (injected beans)
    - EI_EXPOSE_REP: Getter returns reference to mutable object (injected beans)

    Why this is a false positive:
    1. Spring manages bean lifecycle - all injected beans are singletons from Spring context
    2. No external code can call constructors (Spring creates instances via ApplicationContext)
    3. This is the standard Spring DI pattern used in millions of production applications
    4. Alternative (defensive copying) would break Spring's proxy/AOP mechanisms

    Industry consensus: These warnings are universally accepted as false positives for
    Spring applications. See: Spring documentation, SpotBugs issue tracker discussions.
    -->
    <Match>
        <Bug pattern="EI_EXPOSE_REP,EI_EXPOSE_REP2"/>
        <Or>
            <Class name="~.*\.service\..*"/>
            <Class name="~.*\.controller\..*"/>
            <Class name="~.*\.repository\..*"/>
            <Class name="~.*\.config\..*"/>
            <Class name="~.*\.security\..*"/>
            <Class name="~.*\.dto\..*"/>
            <Class name="~.*\.entity\..*"/>
        </Or>
    </Match>

</FindBugsFilter>
